#' Subsets RVC object
#' @export
#' @name select
#' @description Produces a subset of Reef Visual Census data. 
#' @param x
#' An RVC object (generated by \code{\link{rvcData}})
#' @inheritParams rvcData
#' @param stratum 
#' A four-letter code representing the stratum
#' @param protected
#' An integer representing the protected status.
#' @param when_present
#' A boolean. : If true selects only data where species was observed.
#' Throws exception if more than one species selected. Defualt 
#' value is false
#' @param merge_protected
#' A boolean. If TRUE merges protected and unprotected
#' strata together. Default value is false
#' @param length_class 
#' Can be NULL, keyword or number. Must be NULL if more than one species selected, or else throws exception
#' \itemize{
#' \item If NULL does not modify sample data
#' \item If keyword "maturity" or "exploitable", retrieves median length at maturity or capture (respectively) 
#' for the provided species from the server, and uses that as a breakpoint.
#' If not found, throws exception
#' \item If number, the provided number is used as the breakpoint.
#' }
#' @param ...
#' Optional parameters passed to \code{\link{rvcData}}, e.g. server
#' @seealso \code{\link{rvcData}} \code{\link{getStat}}
#' @return Returns an RVC object with two elements:
#' \item{sample_data}{Contains the original sample data subsetted by
#' input arguments}
#' \item{stratum_data}{Contains original stratum data subsetted by
#' input arguments}
select  <- function(x=NULL, species = NULL, year = NULL, region = NULL,
                    stratum = NULL, protected = NULL, 
                    when_present = FALSE, merge_protected = FALSE,
                    length_class = NULL, ...){
  ## If x is NULL, run RVC data and then select
  if (is.null(x)){
    # If any of species, year, or region is null throw exception
    # else make request from server
    v  <- lapply(list(species, year, region), is.null)
    if (do.call(any, v)){
      stop('If x is NULL, species, year, and region cannot be NULL')
    } else {
      x  <- rvcData(species, year, region, ...)
    }
  }
  ## Parse full scientific names are trucated to SPECIES_CD
  species <- if(!is.null(species)){.toSpcCd(species)};
  ## Make region/stratum codes upper case if not already
  region  <- if(!is.null(region)){toupper(region)};
  stratum  <- if(!is.null(stratum)){toupper(stratum)};
  # Throw exception if x is not an RVC object
  if (!inherits(x,"RVC")){
    stop('x must be an RVC object')
  }
  # Subset species and sample data by common values
  # Note: match function part of rvcstats package
  x  <- lapply(x, function(x){subset(x,
          YEAR %match% year &
          REGION %match% region &
          STRAT %match% stratum &
          PROT %match% protected)}
        );
  # Further subset by species 
  x$sample_data  <- subset(x$sample_data, 
                      SPECIES_CD %match% species
                           );
  # If when_present is TRUE, subset by records when 
  # NUM > 0
  if (when_present){
    # Throws error if more than one species is selected
    if (length(unique(x$sample_data$SPECIES_CD))>1){
      stop('when_present cannot be TRUE if more than 
           one species selected');
    }
    x$sample_data  <- subset(x$sample_data, NUM > 0);
  }
  # If length_class != NULL, add two columns, one less than
  # the provided number and one greater 
  if (!is.null(length_class)){
    x$sample_data[paste("<",length_class,sep="")] = ifelse(x$sample_data$LEN < length_class,1,0);
    x$sample_data[paste(">=",length_class,sep="")] = ifelse(x$sample_data$LEN >= length_class,1,0);
    attr(x,"length_classes"  <- TRUE)
  }
  #Calculate weighting. If merge_protected is TRUE add 
  #the NTOTs for protected and unprotected strata together
  x$stratum_data  <- .stratData(x$stratum_data, merge_protected);
  attr(x,"merge_protected")  <- merge_protected;
  # Set class to RVC
  class(x)  <- "RVC"
  return(x)
}